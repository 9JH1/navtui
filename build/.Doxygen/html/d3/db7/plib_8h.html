<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CS12 Database: src/remote/plib/plib.h File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CS12 Database<span id="projectnumber">&#160;2</span>
   </div>
   <div id="projectbrief">A database front and back end for a local library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('d3/db7/plib_8h.html','../../',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">plib.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>argument parsing library  
<a href="#details">More...</a></p>

<p><a href="../../d3/db7/plib_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:dma" id="r_dma"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d20/structdma.html">dma</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">dma struct used in _value of <a class="el" href="../../d4/d1b/structpl__arg.html" title="main struct for arguments">pl_arg</a>  <a href="../../d7/d20/structdma.html#details">More...</a><br /></td></tr>
<tr class="memitem:pl_5Farg" id="r_pl_5Farg"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d1b/structpl__arg.html">pl_arg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">main struct for arguments  <a href="../../d4/d1b/structpl__arg.html#details">More...</a><br /></td></tr>
<tr class="memitem:node" id="r_node"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/da1/structnode.html">node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">node structure  <a href="../../d5/da1/structnode.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ae82e54eaded33c048955580cd5c1d75c" id="r_ae82e54eaded33c048955580cd5c1d75c"><td class="memItemLeft" align="right" valign="top"><a id="ae82e54eaded33c048955580cd5c1d75c" name="ae82e54eaded33c048955580cd5c1d75c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PL_VERBOSE</b>&#160;&#160;&#160;0</td></tr>
<tr class="memitem:a05a7a4a9844fc3725706c22599418f44" id="r_a05a7a4a9844fc3725706c22599418f44"><td class="memItemLeft" align="right" valign="top"><a id="a05a7a4a9844fc3725706c22599418f44" name="a05a7a4a9844fc3725706c22599418f44"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PL_HELP_CAT_INDENT</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a05a7a4a9844fc3725706c22599418f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">amount of spaces indented on items in help menu <br /></td></tr>
<tr class="memitem:a7d3b65191817db0eb86a658b06174fe8" id="r_a7d3b65191817db0eb86a658b06174fe8"><td class="memItemLeft" align="right" valign="top"><a id="a7d3b65191817db0eb86a658b06174fe8" name="a7d3b65191817db0eb86a658b06174fe8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PL_HELP_SEP_ANSI</b>&#160;&#160;&#160;&quot;\033[34m&quot;</td></tr>
<tr class="memitem:ab998d6ff1fdd06937124481e2c76f0eb" id="r_ab998d6ff1fdd06937124481e2c76f0eb"><td class="memItemLeft" align="right" valign="top"><a id="ab998d6ff1fdd06937124481e2c76f0eb" name="ab998d6ff1fdd06937124481e2c76f0eb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PL_HELP_SEL_ANSI</b>&#160;&#160;&#160;&quot;\033[32m&quot;</td></tr>
<tr class="memitem:abb58ec8750f8c4564cf6d01209489605" id="r_abb58ec8750f8c4564cf6d01209489605"><td class="memItemLeft" align="right" valign="top"><a id="abb58ec8750f8c4564cf6d01209489605" name="abb58ec8750f8c4564cf6d01209489605"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PL_HELP_SEP</b>&#160;&#160;&#160;&quot; &quot;</td></tr>
<tr class="memitem:a705a94cd5af90554677e49c5d51c47f3" id="r_a705a94cd5af90554677e49c5d51c47f3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a705a94cd5af90554677e49c5d51c47f3">_I</a>(n)</td></tr>
<tr class="memitem:a2857e1de79b5fb458fe8a672bde8c474" id="r_a2857e1de79b5fb458fe8a672bde8c474"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2857e1de79b5fb458fe8a672bde8c474">PL_L</a>()</td></tr>
<tr class="memdesc:a2857e1de79b5fb458fe8a672bde8c474"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the last argument parsed by plib as a string  <br /></td></tr>
<tr class="memitem:ac79b1ab013efd71cd9c1bbf4d3c11ed4" id="r_ac79b1ab013efd71cd9c1bbf4d3c11ed4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac79b1ab013efd71cd9c1bbf4d3c11ed4">PL_PROC</a>()</td></tr>
<tr class="memdesc:ac79b1ab013efd71cd9c1bbf4d3c11ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">wrapper for pl_proc  <br /></td></tr>
<tr class="memitem:a991dd490011c9bedf0ca70cf4aede352" id="r_a991dd490011c9bedf0ca70cf4aede352"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a991dd490011c9bedf0ca70cf4aede352">PL_G</a>(arg)</td></tr>
<tr class="memdesc:a991dd490011c9bedf0ca70cf4aede352"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the first value run on an arg  <br /></td></tr>
<tr class="memitem:afa837941d3851a06fcd972a976c9431d" id="r_afa837941d3851a06fcd972a976c9431d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa837941d3851a06fcd972a976c9431d">pl_arg_value_count</a>(arg)</td></tr>
<tr class="memdesc:afa837941d3851a06fcd972a976c9431d"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the amount of values an arg has  <br /></td></tr>
<tr class="memitem:a7861a13243875e0d471c6345fdcca7de" id="r_a7861a13243875e0d471c6345fdcca7de"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7861a13243875e0d471c6345fdcca7de">PL_A</a>(...)</td></tr>
<tr class="memdesc:a7861a13243875e0d471c6345fdcca7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">macro wrapper for pl_a  <br /></td></tr>
<tr class="memitem:acbd1b26ec17499d33dcc6aa862f2f888" id="r_acbd1b26ec17499d33dcc6aa862f2f888"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbd1b26ec17499d33dcc6aa862f2f888">PL_R</a>(arg)</td></tr>
<tr class="memdesc:acbd1b26ec17499d33dcc6aa862f2f888"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the type of key arg was run with  <br /></td></tr>
<tr class="memitem:a5150cf3b301dca00c230ddc4fd72e90e" id="r_a5150cf3b301dca00c230ddc4fd72e90e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5150cf3b301dca00c230ddc4fd72e90e">PL_E</a>(ret)</td></tr>
<tr class="memdesc:a5150cf3b301dca00c230ddc4fd72e90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a stringifyed version of an error code  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af4aeda155dbe167f1c1cf38cb65bf324" id="r_af4aeda155dbe167f1c1cf38cb65bf324"><td class="memItemLeft" align="right" valign="top">typedef struct node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4aeda155dbe167f1c1cf38cb65bf324">node</a></td></tr>
<tr class="memdesc:af4aeda155dbe167f1c1cf38cb65bf324"><td class="mdescLeft">&#160;</td><td class="mdescRight">node structure  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:afe6a6572169aee3b8a8e0bceab96c5a9" id="r_afe6a6572169aee3b8a8e0bceab96c5a9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe6a6572169aee3b8a8e0bceab96c5a9">pl_r</a> { <br />
&#160;&#160;<b>PL_NO_ARGS_GIVEN</b> = -1
, <b>PL_NO_ARGS_DEFINED</b> = -2
, <b>PL_SUCCESS</b> = -3
, <b>PL_FAIL</b> = -4
, <br />
&#160;&#160;<b>PL_ARG_NOT_FOUND</b> = -5
, <b>PL_ARG_REQUIRES_VALUE</b> = -6
, <b>PL_ARG_NO_REQUIRE_VALUE</b> = -7
, <b>PL_MEM_ALLOC_ERROR</b> = -8
, <br />
&#160;&#160;<b>PL_ARG_REQUIRED</b> = -9
<br />
 }</td></tr>
<tr class="memdesc:afe6a6572169aee3b8a8e0bceab96c5a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">return codes of various functions  <a href="#afe6a6572169aee3b8a8e0bceab96c5a9">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a49134291d723c7761fbf88b87105327b" id="r_a49134291d723c7761fbf88b87105327b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49134291d723c7761fbf88b87105327b">pl_free</a> ()</td></tr>
<tr class="memdesc:a49134291d723c7761fbf88b87105327b"><td class="mdescLeft">&#160;</td><td class="mdescRight">frees allocated memory of nodes  <br /></td></tr>
<tr class="memitem:ab2963c491879d340a6d185801b67ebaa" id="r_ab2963c491879d340a6d185801b67ebaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2963c491879d340a6d185801b67ebaa">pl_help</a> (void)</td></tr>
<tr class="memdesc:ab2963c491879d340a6d185801b67ebaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">help menu  <br /></td></tr>
<tr class="memitem:a3f643d8dfcf0abfb53c894bea65aef94" id="r_a3f643d8dfcf0abfb53c894bea65aef94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d1b/structpl__arg.html">pl_arg</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f643d8dfcf0abfb53c894bea65aef94">pl_a</a> (<a class="el" href="../../d4/d1b/structpl__arg.html">pl_arg</a> in)</td></tr>
<tr class="memdesc:a3f643d8dfcf0abfb53c894bea65aef94"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an argument  <br /></td></tr>
<tr class="memitem:ac305ab4f6a17a6d3b29fe7f63bf68ee1" id="r_ac305ab4f6a17a6d3b29fe7f63bf68ee1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/da1/structnode.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac305ab4f6a17a6d3b29fe7f63bf68ee1">get_next_node</a> (void)</td></tr>
<tr class="memdesc:ac305ab4f6a17a6d3b29fe7f63bf68ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the next available node  <br /></td></tr>
<tr class="memitem:a61727770604c09632eef7ef537ada8e7" id="r_a61727770604c09632eef7ef537ada8e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61727770604c09632eef7ef537ada8e7">get_next_node_i</a> (void)</td></tr>
<tr class="memdesc:a61727770604c09632eef7ef537ada8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">get next node recurse level  <br /></td></tr>
<tr class="memitem:a19389de9ab6ae82d0b9d76ece5446296" id="r_a19389de9ab6ae82d0b9d76ece5446296"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19389de9ab6ae82d0b9d76ece5446296">pl_proc</a> (const int c, char *v[])</td></tr>
<tr class="memdesc:a19389de9ab6ae82d0b9d76ece5446296"><td class="mdescLeft">&#160;</td><td class="mdescRight">parses argc and argv  <br /></td></tr>
<tr class="memitem:ac3003bc4ff86034484bbf5a72ecb3452" id="r_ac3003bc4ff86034484bbf5a72ecb3452"><td class="memItemLeft" align="right" valign="top"><a id="ac3003bc4ff86034484bbf5a72ecb3452" name="ac3003bc4ff86034484bbf5a72ecb3452"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pl_help_header</b> (void)</td></tr>
<tr class="memitem:a96494165c3b118a5308156f17b6ada09" id="r_a96494165c3b118a5308156f17b6ada09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#afe6a6572169aee3b8a8e0bceab96c5a9">pl_r</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96494165c3b118a5308156f17b6ada09">pl_arg_exist</a> (<a class="el" href="../../d5/da1/structnode.html">node</a> **buf, const char *flag)</td></tr>
<tr class="memdesc:a96494165c3b118a5308156f17b6ada09"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if argument exists by its flag name  <br /></td></tr>
<tr class="memitem:aa62c992546128053692b2397c081ec00" id="r_aa62c992546128053692b2397c081ec00"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa62c992546128053692b2397c081ec00">pl_get_value</a> (const <a class="el" href="../../d4/d1b/structpl__arg.html">pl_arg</a> *arg, const int i)</td></tr>
<tr class="memdesc:aa62c992546128053692b2397c081ec00"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the value of an argument  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa0dd20509222b04db3d1fd9fa4ca2151" id="r_aa0dd20509222b04db3d1fd9fa4ca2151"><td class="memItemLeft" align="right" valign="top"><a id="aa0dd20509222b04db3d1fd9fa4ca2151" name="aa0dd20509222b04db3d1fd9fa4ca2151"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>PL_ARGC</b></td></tr>
<tr class="memdesc:aa0dd20509222b04db3d1fd9fa4ca2151"><td class="mdescLeft">&#160;</td><td class="mdescRight">local copy of argc <br /></td></tr>
<tr class="memitem:a6e1a9946b7cf0b54feed01bbc89b9d1f" id="r_a6e1a9946b7cf0b54feed01bbc89b9d1f"><td class="memItemLeft" align="right" valign="top"><a id="a6e1a9946b7cf0b54feed01bbc89b9d1f" name="a6e1a9946b7cf0b54feed01bbc89b9d1f"></a>
<a class="el" href="../../d5/da1/structnode.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PL_ARGS</b></td></tr>
<tr class="memdesc:a6e1a9946b7cf0b54feed01bbc89b9d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">node table holding pl_args <br /></td></tr>
<tr class="memitem:ac652479936af9912703d22a6cb3ac026" id="r_ac652479936af9912703d22a6cb3ac026"><td class="memItemLeft" align="right" valign="top"><a id="ac652479936af9912703d22a6cb3ac026" name="ac652479936af9912703d22a6cb3ac026"></a>
char **&#160;</td><td class="memItemRight" valign="bottom"><b>PL_ARGV</b></td></tr>
<tr class="memdesc:ac652479936af9912703d22a6cb3ac026"><td class="mdescLeft">&#160;</td><td class="mdescRight">local copy of argv <br /></td></tr>
<tr class="memitem:a5ad844ce3c519c6d09e3664b68fce44c" id="r_a5ad844ce3c519c6d09e3664b68fce44c"><td class="memItemLeft" align="right" valign="top"><a id="a5ad844ce3c519c6d09e3664b68fce44c" name="a5ad844ce3c519c6d09e3664b68fce44c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>PL_MEM_USE</b></td></tr>
<tr class="memitem:a2489790950b64fae879d7b505e05a763" id="r_a2489790950b64fae879d7b505e05a763"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2489790950b64fae879d7b505e05a763">PL_SPLITCHAR</a></td></tr>
<tr class="memdesc:a2489790950b64fae879d7b505e05a763"><td class="mdescLeft">&#160;</td><td class="mdescRight">what character to split arguments at  <br /></td></tr>
<tr class="memitem:aef9b9573bccd15f9ac173b05468408c9" id="r_aef9b9573bccd15f9ac173b05468408c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef9b9573bccd15f9ac173b05468408c9">PL_ARG_LAST_INDEX</a></td></tr>
<tr class="memdesc:aef9b9573bccd15f9ac173b05468408c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">last index of PL_ARGV that was parsed by plib  <br /></td></tr>
<tr class="memitem:a646a4d83631efa2bcd47ca03dd29ebb5" id="r_a646a4d83631efa2bcd47ca03dd29ebb5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a646a4d83631efa2bcd47ca03dd29ebb5">PL_ARG_NOT_FOUND_ERROR</a></td></tr>
<tr class="memdesc:a646a4d83631efa2bcd47ca03dd29ebb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">disable the arg not found error  <br /></td></tr>
<tr class="memitem:aa8c5acfceec33ed5bb68ed9180200552" id="r_aa8c5acfceec33ed5bb68ed9180200552"><td class="memItemLeft" align="right" valign="top"><a id="aa8c5acfceec33ed5bb68ed9180200552" name="aa8c5acfceec33ed5bb68ed9180200552"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>PL_LAST_ARG</b></td></tr>
<tr class="memdesc:aa8c5acfceec33ed5bb68ed9180200552"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the last argument parsed by plib <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>argument parsing library </p>
</div><a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="a705a94cd5af90554677e49c5d51c47f3" name="a705a94cd5af90554677e49c5d51c47f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705a94cd5af90554677e49c5d51c47f3">&#9670;&#160;</a></span>_I</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _I</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((n+1)*-1)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7861a13243875e0d471c6345fdcca7de" name="a7861a13243875e0d471c6345fdcca7de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7861a13243875e0d471c6345fdcca7de">&#9670;&#160;</a></span>PL_A</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PL_A</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em></em></span>...</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">pl_a((<a class="code hl_struct" href="../../d4/d1b/structpl__arg.html">pl_arg</a>){__VA_ARGS__})</div>
<div class="ttc" id="astructpl__arg_html"><div class="ttname"><a href="../../d4/d1b/structpl__arg.html">pl_arg</a></div><div class="ttdoc">main struct for arguments</div><div class="ttdef"><b>Definition</b> plib.h:83</div></div>
</div><!-- fragment -->
<p>macro wrapper for pl_a </p>
<p>removes the need to define the strcure type which changes the code from </p><div class="fragment"><div class="line"><a class="code hl_struct" href="../../d4/d1b/structpl__arg.html">pl_arg</a> * my_arg = <a class="code hl_function" href="#a3f643d8dfcf0abfb53c894bea65aef94">pl_a</a>((<a class="code hl_struct" href="../../d4/d1b/structpl__arg.html">pl_arg</a>){<span class="stringliteral">&quot;--my-arg&quot;</span>,<span class="stringliteral">&quot;description&quot;</span>});</div>
<div class="line"><span class="comment">//                      ^~~~~~ define the pl_arg struct </span></div>
<div class="ttc" id="aplib_8h_html_a3f643d8dfcf0abfb53c894bea65aef94"><div class="ttname"><a href="#a3f643d8dfcf0abfb53c894bea65aef94">pl_a</a></div><div class="ttdeci">pl_arg * pl_a(pl_arg in)</div><div class="ttdoc">create an argument</div><div class="ttdef"><b>Definition</b> plib.c:134</div></div>
</div><!-- fragment --><p> to </p><div class="fragment"><div class="line"><a class="code hl_struct" href="../../d4/d1b/structpl__arg.html">pl_arg</a> * my_arg <a class="code hl_define" href="#a7861a13243875e0d471c6345fdcca7de">PL_A</a>(<span class="stringliteral">&quot;--my-arg&quot;</span>,<span class="stringliteral">&quot;description&quot;</span>);</div>
<div class="line"><span class="comment">//                   ^ no structure name!</span></div>
<div class="ttc" id="aplib_8h_html_a7861a13243875e0d471c6345fdcca7de"><div class="ttname"><a href="#a7861a13243875e0d471c6345fdcca7de">PL_A</a></div><div class="ttdeci">#define PL_A(...)</div><div class="ttdoc">macro wrapper for pl_a</div><div class="ttdef"><b>Definition</b> plib.h:357</div></div>
</div><!-- fragment --><p> so much faster! </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3f643d8dfcf0abfb53c894bea65aef94" title="create an argument">pl_a</a> </dd></dl>

</div>
</div>
<a id="afa837941d3851a06fcd972a976c9431d" name="afa837941d3851a06fcd972a976c9431d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa837941d3851a06fcd972a976c9431d">&#9670;&#160;</a></span>pl_arg_value_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pl_arg_value_count</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(arg._value.index)</div>
</div><!-- fragment -->
<p>get the amount of values an arg has </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a991dd490011c9bedf0ca70cf4aede352" title="gets the first value run on an arg">PL_G</a> </dd>
<dd>
<a class="el" href="#aa62c992546128053692b2397c081ec00" title="gets the value of an argument">pl_get_value</a> </dd></dl>

</div>
</div>
<a id="a5150cf3b301dca00c230ddc4fd72e90e" name="a5150cf3b301dca00c230ddc4fd72e90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5150cf3b301dca00c230ddc4fd72e90e">&#9670;&#160;</a></span>PL_E</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PL_E</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>ret</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">pl_s[(ret+1)*-1]</div>
</div><!-- fragment -->
<p>returns a stringifyed version of an error code </p>
<dl class="section see"><dt>See also</dt><dd>pl_s </dd>
<dd>
<a class="el" href="#afe6a6572169aee3b8a8e0bceab96c5a9" title="return codes of various functions">pl_r</a> </dd></dl>

</div>
</div>
<a id="a991dd490011c9bedf0ca70cf4aede352" name="a991dd490011c9bedf0ca70cf4aede352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991dd490011c9bedf0ca70cf4aede352">&#9670;&#160;</a></span>PL_G</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PL_G</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(arg._value.index &gt; 0) ? pl_get_value(arg, arg-&gt;_value.index) : NULL</div>
</div><!-- fragment -->
<p>gets the first value run on an arg </p>
<dl class="section return"><dt>Returns</dt><dd>first value run with argument </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa62c992546128053692b2397c081ec00" title="gets the value of an argument">pl_get_value</a> </dd>
<dd>
<a class="el" href="#afa837941d3851a06fcd972a976c9431d" title="get the amount of values an arg has">pl_arg_value_count</a> </dd></dl>

</div>
</div>
<a id="a2857e1de79b5fb458fe8a672bde8c474" name="a2857e1de79b5fb458fe8a672bde8c474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2857e1de79b5fb458fe8a672bde8c474">&#9670;&#160;</a></span>PL_L</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PL_L</td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(PL_ARG_LAST_INDEX &gt; 0) ? PL_ARGV[PL_ARG_LAST_INDEX] : <span class="stringliteral">&quot;NO_LAST_ARGUMENT&quot;</span></div>
</div><!-- fragment -->
<p>returns the last argument parsed by plib as a string </p>

</div>
</div>
<a id="ac79b1ab013efd71cd9c1bbf4d3c11ed4" name="ac79b1ab013efd71cd9c1bbf4d3c11ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac79b1ab013efd71cd9c1bbf4d3c11ed4">&#9670;&#160;</a></span>PL_PROC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PL_PROC</td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">pl_proc(argc,argv)</div>
</div><!-- fragment -->
<p>wrapper for pl_proc </p>
<p>automatically takes in argv and argc, will cause errors if argc or argv are not defined. </p>

</div>
</div>
<a id="acbd1b26ec17499d33dcc6aa862f2f888" name="acbd1b26ec17499d33dcc6aa862f2f888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd1b26ec17499d33dcc6aa862f2f888">&#9670;&#160;</a></span>PL_R</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PL_R</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(arg-&gt;_value.index &gt; 0)</div>
</div><!-- fragment -->
<p>get the type of key arg was run with </p>
<p>as mentioned in <a class="el" href="../../d4/d1b/structpl__arg.html">pl_arg</a> there can be a short hand argument added to a flag this is useful for arguments that may need shorter versions eg for a flag of <span class="tt">--help</span> you may want a shorthand of <span class="tt">-h</span></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d4/d1b/structpl__arg.html" title="main struct for arguments">pl_arg</a> </dd></dl>

</div>
</div>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="af4aeda155dbe167f1c1cf38cb65bf324" name="af4aeda155dbe167f1c1cf38cb65bf324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4aeda155dbe167f1c1cf38cb65bf324">&#9670;&#160;</a></span>node</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct node node</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>node structure </p>
<p>This is the structure that recursivly holds all of the arguments information, each node can have another node nested in it. This approach seems strange seeing as you could just use an array right? WRONG!! if you try to use an array and lets say this array is dynamically allocated and has a starting <br  />
 capacity of 2, if for example the pl_a function returned the arguments memory pointer and then the array was reallocated then the address of the pointer is removed and therefore causes a dangling pointer, using nodes means that you do not need to reallocate to add a new item as you just need to allocate the space in the node with the highest recursive level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td><a class="el" href="../../d4/d1b/structpl__arg.html" title="main struct for arguments">pl_arg</a> options </td></tr>
    <tr><td class="paramname">recurse</td><td>unused value </td></tr>
    <tr><td class="paramname">skip,should</td><td>the parser skip this node </td></tr>
    <tr><td class="paramname">init</td><td>has the current node been initialized with a <a class="el" href="../../d4/d1b/structpl__arg.html" title="main struct for arguments">pl_arg</a>? </td></tr>
    <tr><td class="paramname">next</td><td>the next node in the table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="afe6a6572169aee3b8a8e0bceab96c5a9" name="afe6a6572169aee3b8a8e0bceab96c5a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6a6572169aee3b8a8e0bceab96c5a9">&#9670;&#160;</a></span>pl_r</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#afe6a6572169aee3b8a8e0bceab96c5a9">pl_r</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return codes of various functions </p>
<dl class="section see"><dt>See also</dt><dd>pl_s </dd></dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ac305ab4f6a17a6d3b29fe7f63bf68ee1" name="ac305ab4f6a17a6d3b29fe7f63bf68ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac305ab4f6a17a6d3b29fe7f63bf68ee1">&#9670;&#160;</a></span>get_next_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/da1/structnode.html">node</a> * get_next_node </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the next available node </p>
<p>read <a class="el" href="../../d5/da1/structnode.html">node</a> and pl_a when pl_a is called this function is called, this function recurses through the node table until it finds a node that does n not have its .init value set, the .arg value is then set to the *in and the init is toggled on.</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to next available node </dd></dl>

</div>
</div>
<a id="a61727770604c09632eef7ef537ada8e7" name="a61727770604c09632eef7ef537ada8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61727770604c09632eef7ef537ada8e7">&#9670;&#160;</a></span>get_next_node_i()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int get_next_node_i </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get next node recurse level </p>
<p>similar to <a class="el" href="#ac305ab4f6a17a6d3b29fe7f63bf68ee1">get_next_node</a> this function recurses until it finds an argument without the .init value set. the difference is that this function simply returns the amount of recurses required to get to the next free node.</p>
<dl class="section return"><dt>Returns</dt><dd>recurse level of next available node </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac305ab4f6a17a6d3b29fe7f63bf68ee1" title="gets the next available node">get_next_node</a> </dd></dl>

</div>
</div>
<a id="a3f643d8dfcf0abfb53c894bea65aef94" name="a3f643d8dfcf0abfb53c894bea65aef94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f643d8dfcf0abfb53c894bea65aef94">&#9670;&#160;</a></span>pl_a()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d1b/structpl__arg.html">pl_arg</a> * pl_a </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d1b/structpl__arg.html">pl_arg</a></td>          <td class="paramname"><span class="paramname"><em>in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create an argument </p>
<p>adds an argument to PL_ARGS in the form of a node. read @pl_arg to see all of the options</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td><a class="el" href="../../d4/d1b/structpl__arg.html" title="main struct for arguments">pl_arg</a> struct to add to PL_ARGS</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac305ab4f6a17a6d3b29fe7f63bf68ee1" title="gets the next available node">get_next_node</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to argument in PL_ARGS </dd></dl>

</div>
</div>
<a id="a96494165c3b118a5308156f17b6ada09" name="a96494165c3b118a5308156f17b6ada09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96494165c3b118a5308156f17b6ada09">&#9670;&#160;</a></span>pl_arg_exist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#afe6a6572169aee3b8a8e0bceab96c5a9">pl_r</a> pl_arg_exist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/da1/structnode.html">node</a> **</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if argument exists by its flag name </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>flag string to search for </td></tr>
    <tr><td class="paramname">buf</td><td>buffer that returns the node the argument was found in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49134291d723c7761fbf88b87105327b" name="a49134291d723c7761fbf88b87105327b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49134291d723c7761fbf88b87105327b">&#9670;&#160;</a></span>pl_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pl_free </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>frees allocated memory of nodes </p>
<p>this function is called on exit </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac79b1ab013efd71cd9c1bbf4d3c11ed4" title="wrapper for pl_proc">PL_PROC</a> </dd>
<dd>
<a class="el" href="../../d5/da1/structnode.html" title="node structure">node</a> </dd></dl>

</div>
</div>
<a id="aa62c992546128053692b2397c081ec00" name="aa62c992546128053692b2397c081ec00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62c992546128053692b2397c081ec00">&#9670;&#160;</a></span>pl_get_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * pl_get_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d1b/structpl__arg.html">pl_arg</a> *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the value of an argument </p>
<p>arguments can have multiple values, these values are stored in a dynamically allocated array using the <a class="el" href="../../d7/d20/structdma.html">dma</a> struct. because there are multiple values this function takes in an index which returns that index of values.</p>
<p>if you only expect one argument then use <a class="el" href="#a991dd490011c9bedf0ca70cf4aede352">PL_G</a> which returns the first item in an argument</p>
<p>use <a class="el" href="#afa837941d3851a06fcd972a976c9431d">pl_arg_value_count</a> to get the total amount of arguments availble</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#afa837941d3851a06fcd972a976c9431d" title="get the amount of values an arg has">pl_arg_value_count</a> </dd>
<dd>
<a class="el" href="#a991dd490011c9bedf0ca70cf4aede352" title="gets the first value run on an arg">PL_G</a> </dd></dl>

</div>
</div>
<a id="ab2963c491879d340a6d185801b67ebaa" name="ab2963c491879d340a6d185801b67ebaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2963c491879d340a6d185801b67ebaa">&#9670;&#160;</a></span>pl_help()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pl_help </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>help menu </p>
<dl class="section see"><dt>See also</dt><dd>PL_HELP_SEP_ANSI </dd>
<dd>
PL_HELP_SEL_ANSI </dd>
<dd>
<a class="el" href="#a05a7a4a9844fc3725706c22599418f44" title="amount of spaces indented on items in help menu">PL_HELP_CAT_INDENT</a> </dd></dl>

</div>
</div>
<a id="a19389de9ab6ae82d0b9d76ece5446296" name="a19389de9ab6ae82d0b9d76ece5446296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19389de9ab6ae82d0b9d76ece5446296">&#9670;&#160;</a></span>pl_proc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pl_proc </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>v</em></span>[]&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parses argc and argv </p>
<p>loops through arguments and splits them at the first PL_SPLITCHAR char, then they are run through <a class="el" href="#a96494165c3b118a5308156f17b6ada09">pl_arg_exist</a> to see if the argument exists or not. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac79b1ab013efd71cd9c1bbf4d3c11ed4" title="wrapper for pl_proc">PL_PROC</a> </dd></dl>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="aef9b9573bccd15f9ac173b05468408c9" name="aef9b9573bccd15f9ac173b05468408c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef9b9573bccd15f9ac173b05468408c9">&#9670;&#160;</a></span>PL_ARG_LAST_INDEX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PL_ARG_LAST_INDEX</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>last index of PL_ARGV that was parsed by plib </p>
<p>The last index of PL_ARGV that was parsed by plib this will be useful in error detection as you can easily get the argument that got caused the error by getting PL_ARGV[PL_ARG_LAST_INDEX]; or use <a class="el" href="#a2857e1de79b5fb458fe8a672bde8c474">PL_L</a>. </p>

</div>
</div>
<a id="a646a4d83631efa2bcd47ca03dd29ebb5" name="a646a4d83631efa2bcd47ca03dd29ebb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a646a4d83631efa2bcd47ca03dd29ebb5">&#9670;&#160;</a></span>PL_ARG_NOT_FOUND_ERROR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PL_ARG_NOT_FOUND_ERROR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>disable the arg not found error </p>
<p>As seen in the PL_SPLITCHAR description this value will disable <a class="el" href="#a19389de9ab6ae82d0b9d76ece5446296">pl_proc</a> return on arg not found error this is useful when running dual argument split chars as pl wont stop parsing until EVERY argument has been either validated or not.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2489790950b64fae879d7b505e05a763" title="what character to split arguments at">PL_SPLITCHAR</a> </dd></dl>

</div>
</div>
<a id="a2489790950b64fae879d7b505e05a763" name="a2489790950b64fae879d7b505e05a763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2489790950b64fae879d7b505e05a763">&#9670;&#160;</a></span>PL_SPLITCHAR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char PL_SPLITCHAR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>what character to split arguments at </p>
<p>this is useful for many reasons for example if you wanted to use it normally it splits at the '=' char meaning &ndash;test=123 is interpreted as key: &ndash;test, val: 123, if you wanted to have cool arguments like gccs -WMY_VALUE_HERE or -DMY_VALUE_HERE you can set up an argument with a flag name of '-' and change the splitchar to 'D' or 'W' you can parse -DMY_VALUE into key: -, val: MY_VALUE. you can dual parse both regular and alternative splutchars in unison like so:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="../../d4/d1b/structpl__arg.html">pl_arg</a> *test1 = <a class="code hl_define" href="#a7861a13243875e0d471c6345fdcca7de">PL_A</a>(.flag = <span class="stringliteral">&quot;--test&quot;</span>, <span class="stringliteral">&quot;basic test arg&quot;</span>,.takes_value=1);</div>
<div class="line"><span class="comment">// disable parser quit on arg not found</span></div>
<div class="line"><a class="code hl_variable" href="#a646a4d83631efa2bcd47ca03dd29ebb5">PL_ARG_NOT_FOUND_ERROR</a> = 0; </div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#a19389de9ab6ae82d0b9d76ece5446296">pl_proc</a>(c, argv);</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_define" href="#acbd1b26ec17499d33dcc6aa862f2f888">PL_R</a>(test1))</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; test1-&gt;_value.index; i++)</div>
<div class="line">    printf(<span class="stringliteral">&quot;value: %s\n&quot;</span>, <a class="code hl_function" href="#aa62c992546128053692b2397c081ec00">pl_get_value</a>(test1, i));</div>
<div class="line">    </div>
<div class="line"><a class="code hl_struct" href="../../d4/d1b/structpl__arg.html">pl_arg</a> *test2 = <a class="code hl_define" href="#a7861a13243875e0d471c6345fdcca7de">PL_A</a>(.flag = <span class="stringliteral">&quot;-&quot;</span>, .takes_value = 1);</div>
<div class="line"><a class="code hl_variable" href="#a2489790950b64fae879d7b505e05a763">PL_SPLITCHAR</a> = <span class="charliteral">&#39;D&#39;</span>;</div>
<div class="line"><a class="code hl_function" href="#a19389de9ab6ae82d0b9d76ece5446296">pl_proc</a>(c, argv);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_define" href="#acbd1b26ec17499d33dcc6aa862f2f888">PL_R</a>(test2))</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; test2-&gt;_value.index; i++)</div>
<div class="line">    printf(<span class="stringliteral">&quot;value: %s\n&quot;</span>, <a class="code hl_function" href="#aa62c992546128053692b2397c081ec00">pl_get_value</a>(test2, i));</div>
<div class="ttc" id="aplib_8h_html_a19389de9ab6ae82d0b9d76ece5446296"><div class="ttname"><a href="#a19389de9ab6ae82d0b9d76ece5446296">pl_proc</a></div><div class="ttdeci">int pl_proc(const int c, char *v[])</div><div class="ttdoc">parses argc and argv</div><div class="ttdef"><b>Definition</b> plib.c:191</div></div>
<div class="ttc" id="aplib_8h_html_a2489790950b64fae879d7b505e05a763"><div class="ttname"><a href="#a2489790950b64fae879d7b505e05a763">PL_SPLITCHAR</a></div><div class="ttdeci">char PL_SPLITCHAR</div><div class="ttdoc">what character to split arguments at</div><div class="ttdef"><b>Definition</b> plib.c:81</div></div>
<div class="ttc" id="aplib_8h_html_a646a4d83631efa2bcd47ca03dd29ebb5"><div class="ttname"><a href="#a646a4d83631efa2bcd47ca03dd29ebb5">PL_ARG_NOT_FOUND_ERROR</a></div><div class="ttdeci">int PL_ARG_NOT_FOUND_ERROR</div><div class="ttdoc">disable the arg not found error</div><div class="ttdef"><b>Definition</b> plib.c:83</div></div>
<div class="ttc" id="aplib_8h_html_aa62c992546128053692b2397c081ec00"><div class="ttname"><a href="#aa62c992546128053692b2397c081ec00">pl_get_value</a></div><div class="ttdeci">char * pl_get_value(const pl_arg *arg, const int i)</div><div class="ttdoc">gets the value of an argument</div><div class="ttdef"><b>Definition</b> plib.c:335</div></div>
<div class="ttc" id="aplib_8h_html_acbd1b26ec17499d33dcc6aa862f2f888"><div class="ttname"><a href="#acbd1b26ec17499d33dcc6aa862f2f888">PL_R</a></div><div class="ttdeci">#define PL_R(arg)</div><div class="ttdoc">get the type of key arg was run with</div><div class="ttdef"><b>Definition</b> plib.h:369</div></div>
</div><!-- fragment --><p>with the above code running </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="../../dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a href="../../dir_fe2e0cb949cafcffa084908b3ca2f11a.html">remote</a></li><li class="navelem"><a href="../../dir_ccc9e1c0436a14b6025ecbfd3cce46e3.html">plib</a></li><li class="navelem"><a href="../../d3/db7/plib_8h.html">plib.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
